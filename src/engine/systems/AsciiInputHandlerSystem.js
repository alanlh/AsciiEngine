import System from "./System.js";
import ModuleSlots from "../modules/ModuleSlots.js";

/**
 * Handles events from mouse and keyboard
 * Mouse events are sent by AsciiGL. 
 * This system should only be used with AsciiGL as the graphics library,
 * and the built-in KeyboardInputModule for keyboard events.
 * 
 * Allows for focusing. An entity is focused iff it is registered as a focusable element,
 * and a click event occurred on it. 
 * If there is a focused entity, keyboard events will only be sent to the system that
 * registered focus for that element.
 * Once an entity has been registered as focusable, other systems cannot register focus for
 * that element until the initial system releases it.
 * If an element is no longer used, it should be unregistered.
 * If no entity is focused, keyboard events will be sent to all systems
 */
export default class AsciiInputHandlerSystem extends System {
  /**
   * 
   * @param {string} [name] The name for the system. "AsciiInputHandler" by default
   */
  constructor(name) {
    super(name || "AsciiInputHandler");
    // TODO: Do we actually need to keep track of this?
    /**
     * @private
     */
    this._mouseEventsEnabled = false;
    /**
     * @private
     */
    this._keyboardEventsEnabled = false;

    /**
     * @private
     */
    this._focusedElement = undefined;
    /**
     * @private
     */
    this._focusableEntityOwners = {};
  }

  startup() {
    let asciiGl = this.getEngine().getModule(ModuleSlots.Graphics);
    if (asciiGl !== undefined) {
      asciiGl.setHandler(this._mouseEventHandler.bind(this));
      this._mouseEventsEnabled = true;
    }

    let keyboardInputModule = this.getEngine().getModule(ModuleSlots.KeyboardInput);
    if (keyboardInputModule !== undefined) {
      keyboardInputModule.addEventListener(this._keyboardEventHandler.bind(this));
      this._keyboardEventsEnabled = true;
    }

    // Enable focus checking iff both mouse and keyboard events are available.
    if (this.mouseEventsEnabled && this.keyboardEventsEnabled) {
      this.subscribe(["InputHandlerRequest", "AddFocusable"], this._handleAddFocusable, true);
      this.subscribe(["InputHandlerRequest", "RemoveFocusable"], this._handleRemoveFocusable, true);
      this.subscribe(["InputHandlerRequest", "SetFocusRequest"], this._handleSetFocusRequest, true);
      this.subscribe(["InputHandlerRequest", "ReleaseFocus"], this._handleReleaseFocus, true);
    }
  }

  /**
   * @returns {boolean}
   */
  get mouseEventsEnabled() {
    return this._mouseEventsEnabled;
  }

  /**
   * @returns {boolean}
   */
  get keyboardEventsEnabled() {
    return this._keyboardEventsEnabled;
  }

  /**
   * Receives mouse input messages from AsciiGL and forwards them to the System Message Board.
   * The event descriptor always begins with ["MouseEvent", eventType].
   * If there is a named target being clicked, it will be appended.
   * 
   * @param {MouseEvent} event The MouseEvent object generated by the browser
   * @param {string} target The target element's name, if defined
   * @param {string} type The event type
   * @param {{x: number, y: number}} coords The location of the mouse event on the screen.
   */
  _mouseEventHandler(event, type, target, coords) {
    this.postMessage(
      ["MouseEvent", target || "", type],
      {
        event: event,
        coords: coords,
      },
    );
    if (type === "click") {
      this._switchFocus(target, coords);
    }
  }

  /**
   * Receives keyboard events from KeyboardInputModule and forwards them to the System Message Board
   * The event descriptor is 
   * ["KeyboardEvent", eventType [, key category[, key subcategory...]], event.key]
   * Current key categories include:
   * Visible: Any visible character
   *    - Alphabetical: a-z A-Z
   *      - Lower: a-z
   *      - Upper: A-Z
   *    - Numeric: 0-9
   *    - Symbol: Everything else
   * Arrow: One of the four arrow keys
   * 
   * @param {string} eventName The type of event
   * @param {string} eventKey The name of the key that triggered the event
   * @param {KeyboardEvent} event The event object generated by the browser.
   */
  _keyboardEventHandler(eventName, eventKey, event) {
    let target = (this._focusedElement !== undefined) ? this._focusedElement : "";
    let eventDescriptor = undefined;
    if (eventKey.length === 1) {
      let keyCode = eventKey.charCodeAt(0);
      if (keyCode >= 48 && keyCode <= 57) {
        eventDescriptor = ["KeyboardEvent", target, eventName, "Visible", "Numeric", eventKey];
      } else if (keyCode >= 65 && keyCode <= 90) {
        eventDescriptor = ["KeyboardEvent", target, eventName, "Visible", "Alphabetical", "Upper", eventKey];
      } else if (keyCode >= 97 && keyCode <= 122) {
        eventDescriptor = ["KeyboardEvent", target, eventName, "Visible", "Alphabetical", "Lower", eventKey];
      } else {
        eventDescriptor = ["KeyboardEvent", target, eventName, "Visible", "Symbol", eventKey];
      }
    } else if (eventKey.startsWith("Arrow")) {
      eventDescriptor = ["KeyboardEvent", target, eventName, "Arrow", eventKey];
    } else {
      eventDescriptor = ["KeyboardEvent", target, eventName, eventKey];
    }
    let body = {
      event: event,
    };
    if (this._focusedElement !== undefined) {
      body.targetEntity = this._focusedElement;
      this.postMessage(
        eventDescriptor,
        body,
        this._focusableEntityOwners[this._focusedElement]
      );
    } else {
      this.postMessage(
        eventDescriptor,
        body,
      );
    }
  }

  /**
   * 
   * @param {string} entityId The event body.
   *    Should be the id of the entity to register. 
   * @param {Array<string>} _descriptor
   * @param {string} sender The name of the System registering the entity
   */
  _handleAddFocusable(entityId, _descriptor, sender) {
    if (!(entityId in this._focusableEntityOwners)) {
      this._focusableEntityOwners[entityId] = sender;
    }
  }

  /**
   * Unregisters the entity from being focusable.
   * The message sender should be the same System that registered the entity.
   * However this *currently* is not enforced.
   * 
   * @param {any} entityId The event body
   *    Should be the id of the entity to unregister
   */
  _handleRemoveFocusable(entityId) {
    if (entityId in this._focusableEntityOwners) {
      if (this._focusedElement === entityId) {
        this._switchFocus();
      }
      delete this._focusableEntityOwners[entityId];
    }
  }

  /**
   * Programatically tries to set focus to an entity. 
   * For now, this will always work, but logic may be added later for situations
   * where we don't want this to happen.
   * 
   * The message sender should be the same System that registered the entity.
   * However, this *currently* is not enforced. 
   * 
   * Systems should not assume that the set focus was successful unless the FocusSet message is received.
   * 
   * @param {any} entityId The event body
   *    Should be the id of the entity to focus.
   */
  _handleSetFocusRequest(entityId) {
    if (entityId in this._focusableEntityOwners) {
      this._switchFocus(entityId);
    }
  }

  /**
   * Programmatically releases focus from an entity if it is currently focused.
   * The message sender should be the same System that registered the entity.
   * However, this is not enforced.
   *
   * @param {any} entityId The event body
   *    Should be the id of the entity to release focus from.
   */
  _handleReleaseFocus(entityId) {
    if (this._focusedElement !== undefined && this._focusedElement === entityId) {
      this._switchFocus();
    }
  }

  /**
   * Switches focus to the specified id. That id should be registered already.
   * Does not do error checking.
   * @param {string} newFocusedId The new id to focus on.
   * @param {{x: number, y: number}} [coords] The global location being focused.
   */
  _switchFocus(newFocusedId, coords) {
    let currFocusedId = this._focusedElement;
    if (currFocusedId !== undefined && currFocusedId !== newFocusedId) {
      this.postMessage(["InputHandlerFocusEvent", currFocusedId, "FocusLost"],
        {
          entityId: currFocusedId
        }, this._focusableEntityOwners[currFocusedId]);
      this._focusedElement = undefined;
    }
    if (newFocusedId !== undefined && currFocusedId !== newFocusedId) {
      this._focusedElement = newFocusedId;
      this.postMessage(["InputHandlerFocusEvent", newFocusedId, "FocusSet"],
        {
          entityId: newFocusedId,
          coords: coords,
        }, this._focusableEntityOwners[newFocusedId]);
    }
  }
}